{"version":3,"sources":["Pathfinding/SingleNode.js","pathfindingAlgorithms/dijkstra.js","mazeGenerator/recursiveDivision.js","mazeGenerator/simpleVerticalWalls.js","mazeGenerator/recursiveBacktracking.js","Pathfinding/PathfindingVisualizer.js","App.js","index.js"],"names":["SingleNode","props","onDragOver","e","preventDefault","onDragStart","obj","target","parentNode","classList","dataTransfer","setData","id","onDrop","stopPropagation","data","getData","setStartNode","row","col","setFinishNode","isStart","appendChild","document","getElementById","state","this","isFinish","isVisited","isWall","onMouseEnter","onMouseDown","onMouseUp","extraClassName","className","aria-label","role","draggable","React","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","differenceArr","RecursiveBacktracking","dirs","gridH","gridMap","gridW","h","w","map","modDir","console","log","querySelectorAll","forEach","el","isNaN","mh","mw","n","s","v","y","x","o","build","i","j","py","px","d","explore","toGrid","ex","ey","sortRand","nx","ny","a","out","l","p","Math","floor","random","onClick","Maze","animateGrid","gapsArr","RecursiveDivision","clearBoard","getInitialGrid","updateGridState","addOuterWalls","addInnerWalls","display","minX","maxX","minY","maxY","randomNumber","addHWall","addVWall","hole","min","max","task","timer","ms","Promise","res","setTimeout","generate","animateGridArr","gapArr","SimpleVerticalWalls","counter","num","gap","includes","animateWalls","verticalWalls","NODE_START","NODE_FINISH","TABLE_HEIGHT","TABLE_WIDTH","PathfindingVisualizer","newGrid","setState","mouseIsPressed","getNewGridWithWallToggled","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","animateShortestPath","visualizeDijkstra","rowIndex","key","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.fdd681bf.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nclass SingleNode extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  onDragOver = e => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  onDragStart = (e, obj) => {\r\n    e.target.parentNode.classList = \"node \";\r\n    e.dataTransfer.setData(\"text\", e.target.id);\r\n  };\r\n\r\n  onDrop = (e, obj) => {\r\n    e.stopPropagation();\r\n    e.preventDefault();\r\n    let data = e.dataTransfer.getData(\"text/plain\");\r\n\r\n    if (data === \"start-node\") {\r\n      e.target.classList = \"node node__start\";\r\n      this.props.setStartNode(obj.props.row, obj.props.col);\r\n    } else if (data === \"finish-node\") {\r\n      e.target.classList = \"node node__finish\";\r\n      this.props.setFinishNode(obj.props.row, obj.props.col);\r\n    }\r\n    if (!obj.props.isStart) {\r\n      e.target.appendChild(document.getElementById(data));\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseEnter,\r\n      onMouseDown,\r\n      onMouseUp\r\n    } = this.props;\r\n    const extraClassName = isStart\r\n      ? \"node__start\"\r\n      : isFinish\r\n      ? \"node__finish\"\r\n      : isVisited\r\n      ? \"node__visited\"\r\n      : isWall\r\n      ? \"node__wall\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onDrop={e => this.onDrop(e, this)}\r\n        onDragOver={e => this.onDragOver(e)}\r\n      >\r\n        {isStart ? (\r\n          <span\r\n            aria-label=\"startNode\"\r\n            id=\"start-node\"\r\n            role=\"img\"\r\n            draggable=\"true\"\r\n            onDragStart={e => this.onDragStart(e, this)}\r\n          >\r\n            ▶️\r\n          </span>\r\n        ) : isFinish ? (\r\n          <span\r\n            aria-label=\"finishNode\"\r\n            id=\"finish-node\"\r\n            role=\"img\"\r\n            draggable=\"true\"\r\n            onDragStart={e => this.onDragStart(e, this)}\r\n          >\r\n            🏁\r\n          </span>\r\n        ) : (\r\n          \" \"\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SingleNode;\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\n\r\nlet grid;\r\nlet animateGrid = [];\r\nlet gapsArr = [];\r\n\r\nclass RecursiveDivision extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  generate(props) {\r\n    animateGrid = [];\r\n\r\n    this.clearBoard(props);\r\n\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.addOuterWalls();\r\n    this.addInnerWalls(true, 1, grid[0].length - 2, 1, grid.length - 2);\r\n    this.display();\r\n  }\r\n\r\n  addOuterWalls() {\r\n    for (var i = 0; i < grid.length; i++) {\r\n      for (var j = 0; j < grid[i].length; j++) {\r\n        if (i === 0 || i === grid.length - 1) {\r\n          animateGrid.push(grid[i][j]);\r\n        } else if (j === 0 || j === grid[i].length - 1) {\r\n          animateGrid.push(grid[i][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  addInnerWalls(h, minX, maxX, minY, maxY) {\r\n    if (h) {\r\n      if (maxX - minX < 2) {\r\n        return;\r\n      }\r\n\r\n      var y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2;\r\n      this.addHWall(minX, maxX, y);\r\n\r\n      this.addInnerWalls(!h, minX, maxX, minY, y - 1);\r\n      this.addInnerWalls(!h, minX, maxX, y + 1, maxY);\r\n    } else {\r\n      if (maxY - minY < 2) {\r\n        return;\r\n      }\r\n\r\n      var x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2;\r\n      this.addVWall(minY, maxY, x);\r\n\r\n      this.addInnerWalls(!h, minX, x - 1, minY, maxY);\r\n      this.addInnerWalls(!h, x + 1, maxX, minY, maxY);\r\n    }\r\n  }\r\n\r\n  addHWall(minX, maxX, y) {\r\n    var hole = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1;\r\n    gapsArr.push(grid[y][hole]);\r\n\r\n    for (var i = minX; i <= maxX; i++) {\r\n      if (i !== hole) {\r\n        animateGrid.push(grid[y][i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  addVWall(minY, maxY, x) {\r\n    var hole = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\r\n    gapsArr.push(grid[hole][x]);\r\n\r\n    for (var i = minY; i <= maxY; i++) {\r\n      if (i !== hole) {\r\n        animateGrid.push(grid[i][x]);\r\n      }\r\n    }\r\n  }\r\n\r\n  randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n  }\r\n\r\n  async display() {\r\n    for (let i = 0; i < animateGrid.length; i++) {\r\n      await this.task(animateGrid, i);\r\n      animateGrid[i].isWall = true;\r\n    }\r\n\r\n    for (let i = 0; i < gapsArr.length; i++) {\r\n      gapsArr[i].isWall = false;\r\n    }\r\n  }\r\n\r\n  clearBoard(props) {\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      el.className = \"node \";\r\n      if (el.id === `node-${props.startNode[0]}-${props.startNode[1]}`) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (el.id === `node-${props.finishNode[0]}-${props.finishNode[1]}`) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n  }\r\n\r\n  async task(animateGrid, i) {\r\n    await this.timer(1);\r\n    const node = animateGrid[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button onClick={() => this.generate(props)}>\r\n        Generate Maze -> Revursive Division\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RecursiveDivision;\r\n","import React from \"react\";\r\n\r\nlet grid;\r\nlet animateGridArr = [];\r\nlet gapArr = [];\r\nlet differenceArr;\r\n\r\nclass SimpleVerticalWalls extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  verticalWalls(props) {\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      if (el.className !== \"node node__wall\") {\r\n        el.className = \"node \";\r\n      }\r\n      if (el.id === `node-${props.startNode[0]}-${props.startNode[1]}`) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (el.id === `node-${props.finishNode[0]}-${props.finishNode[1]}`) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    let counter = 0;\r\n\r\n    for (let row = 0; row < grid.length; row++) {\r\n      for (let col = 0; col < grid[row].length; col++) {\r\n        if (\r\n          row === 0 ||\r\n          col === 0 ||\r\n          row === grid.length - 1 ||\r\n          col === grid[row].length - 1\r\n        ) {\r\n          animateGridArr.push(grid[row][col]);\r\n        } else if (col % 2 === 0) {\r\n          animateGridArr.push(grid[row][col]);\r\n          if (counter < col / 2) {\r\n            const num = Math.floor(Math.random() * (grid.length - 2)) + 1;\r\n            const gap = grid[num][col];\r\n            gapArr.push(grid[gap.row][gap.col]);\r\n          }\r\n          counter++;\r\n        }\r\n      }\r\n    }\r\n\r\n    differenceArr = animateGridArr.filter(x => !gapArr.includes(x));\r\n\r\n    this.animateWalls();\r\n  }\r\n\r\n  async animateWalls() {\r\n    for (let i = 0; i < differenceArr.length; i++) {\r\n      await this.task(differenceArr, i);\r\n      differenceArr[i].isWall = true;\r\n    }\r\n  }\r\n\r\n  async task(animateGrid, i) {\r\n    await this.timer(1);\r\n    const node = animateGrid[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button onClick={() => this.verticalWalls(props)}>\r\n        Generate Maze -> Horizontal Walls\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SimpleVerticalWalls;\r\n","import React from \"react\";\r\n\r\nclass RecursiveBacktracking extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.dirs = [];\r\n    this.gridH = 0;\r\n    this.gridMap = [];\r\n    this.gridW = 0;\r\n    this.h = 0;\r\n    this.w = 0;\r\n    this.map = [];\r\n    this.modDir = {};\r\n  }\r\n\r\n  Maze(w, h, props) {\r\n    console.log(w, h);\r\n\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      if (el.className !== \"node node__wall\") {\r\n        el.className = \"node \";\r\n      }\r\n      if (el.id === `node-${props.startNode[0]}-${props.startNode[1]}`) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (el.id === `node-${props.finishNode[0]}-${props.finishNode[1]}`) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n\r\n    // grid = props.grid;\r\n    // grid = props.getInitialGrid();\r\n    // props.updateGridState(grid);\r\n\r\n    this.w = isNaN(w) || w < 5 || w > 999 ? 20 : w;\r\n    this.h = isNaN(h) || h < 5 || h > 999 ? 20 : h;\r\n    this.map = [];\r\n\r\n    for (var mh = 0; mh < h; ++mh) {\r\n      this.map[mh] = [];\r\n      for (var mw = 0; mw < w; ++mw) {\r\n        this.map[mh][mw] = { n: 0, s: 0, e: 0, w: 0, v: 0 };\r\n      }\r\n    }\r\n\r\n    this.dirs = [\"n\", \"s\", \"e\", \"w\"];\r\n    this.modDir = {\r\n      n: { y: -1, x: 0, o: \"s\" },\r\n      s: { y: 1, x: 0, o: \"n\" },\r\n      e: { y: 0, x: -1, o: \"w\" },\r\n      w: { y: 0, x: 1, o: \"e\" }\r\n    };\r\n\r\n    this.build(0, 0);\r\n    console.log(this.gridMap);\r\n\r\n    for (let i = 0; i < this.gridMap.length - 1; i++) {\r\n      for (let j = 0; j < this.gridMap[i].length - 1; j++) {\r\n        if (this.gridMap[i][j] === 0) {\r\n          document.getElementById(`node-${i}-${j}`).className =\r\n            \"node node__wall\";\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  toGrid() {\r\n    var grid = [];\r\n    for (var mh = 0; mh < this.h * 2 + 1; ++mh) {\r\n      grid[mh] = [];\r\n      for (var mw = 0; mw < this.w * 2 + 1; ++mw) {\r\n        grid[mh][mw] = 0;\r\n      }\r\n    }\r\n\r\n    for (var y = 0; y < this.h; ++y) {\r\n      var py = y * 2 + 1;\r\n\r\n      for (var x = 0; x < this.w; ++x) {\r\n        var px = x * 2 + 1;\r\n\r\n        if (this.map[y][x].v === 1) {\r\n          grid[py][px] = 1;\r\n        }\r\n\r\n        for (let d in this.dirs) {\r\n          if (this.map[y][x][this.dirs[d]] === 1) {\r\n            grid[py + this.modDir[this.dirs[d]].y][\r\n              px + this.modDir[this.dirs[d]].x\r\n            ] = 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.gridMap = grid;\r\n    this.gridW = grid.length;\r\n    this.gridH = grid[0].length;\r\n  }\r\n\r\n  build(x, y) {\r\n    x = 0;\r\n    y = 0;\r\n\r\n    this.explore(x, y);\r\n    this.toGrid();\r\n  }\r\n\r\n  explore(ex, ey) {\r\n    this.dirs = this.sortRand(this.dirs);\r\n\r\n    for (let d in this.dirs) {\r\n      var nx = ex + this.modDir[this.dirs[d]].x;\r\n      var ny = ey + this.modDir[this.dirs[d]].y;\r\n\r\n      if (\r\n        nx >= 0 &&\r\n        nx < this.w &&\r\n        ny >= 0 &&\r\n        ny < this.h &&\r\n        this.map[ny][nx].v === 0\r\n      ) {\r\n        this.map[ey][ex][this.dirs[d]] = 1;\r\n        this.map[ey][ex].v = 1;\r\n        this.map[ny][nx][this.modDir[this.dirs[d]].o] = 1;\r\n\r\n        this.explore(nx, ny);\r\n      }\r\n    }\r\n  }\r\n\r\n  sortRand(a) {\r\n    var out = [];\r\n    var l = a.length;\r\n\r\n    for (let x in a) {\r\n      do {\r\n        var p = Math.floor(Math.random() * (l * 1000)) % l;\r\n      } while (typeof out[p] != \"undefined\");\r\n\r\n      out[p] = a[x];\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button\r\n        onClick={() =>\r\n          this.Maze(props.grid[0].length / 2, props.grid.length / 2, props)\r\n        }\r\n      >\r\n        Generate Maze -> Recursive Backtraciking\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RecursiveBacktracking;\r\n","import React from \"react\";\r\nimport SingleNode from \"./SingleNode\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../pathfindingAlgorithms/dijkstra\";\r\nimport RecursiveBacktracking from \"../mazeGenerator/recursiveBacktracking\";\r\nimport RecursiveDivision from \"../mazeGenerator/recursiveDivision\";\r\nimport SimpleVerticalWalls from \"../mazeGenerator/simpleVerticalWalls\";\r\n\r\nconst TABLE_WIDTH = 85;\r\nconst TABLE_HEIGHT = 37;\r\nconst NODE_START = [1, 1];\r\nconst NODE_FINISH = [TABLE_HEIGHT - 2, TABLE_WIDTH - 2];\r\n\r\nexport default class PathfindingVisualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      startNode: [NODE_START[0], NODE_START[1]],\r\n      finishNode: [NODE_FINISH[0], NODE_FINISH[1]]\r\n    };\r\n  }\r\n\r\n  // #region Helper Functions\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (\r\n      !this.state.grid[row][col].isStart &&\r\n      !this.state.grid[row][col].isFinish\r\n    ) {\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  setStartNode(row, col) {\r\n    this.setState({ startNode: [row, col] });\r\n  }\r\n\r\n  setFinishNode(row, col) {\r\n    this.setState({ finishNode: [row, col] });\r\n  }\r\n\r\n  toggleWalls(grid, row, col) {\r\n    if (!grid[row][col].isWall) {\r\n      grid[row][col].isWall = true;\r\n    } else {\r\n      grid[row][col].isWall = false;\r\n    }\r\n  }\r\n\r\n  updateGridState = newGrid => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  // #endregion\r\n\r\n  // #region Dijkstra pathfinding algorithm\r\n\r\n  visualizeDijkstra() {\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      if (el.className !== \"node node__wall\") {\r\n        el.className = \"node \";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.startNode[0]}-${this.state.startNode[1]}`\r\n      ) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.finishNode[0]}-${this.state.finishNode[1]}`\r\n      ) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startNode[0]][this.state.startNode[1]];\r\n    const finishNode = grid[this.state.finishNode[0]][this.state.finishNode[1]];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node__visited\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node__shortest-path\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  // #endregion\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    return (\r\n      <>\r\n        <div className=\"config-buttons\">\r\n          <button onClick={() => this.visualizeDijkstra()}>\r\n            Visualize Dijkstra's Algorithm\r\n          </button>\r\n          <SimpleVerticalWalls\r\n            grid={grid}\r\n            getInitialGrid={getInitialGrid}\r\n            updateGridState={this.updateGridState}\r\n            startNode={this.state.startNode}\r\n            finishNode={this.state.finishNode}\r\n          />\r\n          <RecursiveDivision\r\n            grid={grid}\r\n            getInitialGrid={getInitialGrid}\r\n            updateGridState={this.updateGridState}\r\n            startNode={this.state.startNode}\r\n            finishNode={this.state.finishNode}\r\n          />\r\n          <RecursiveBacktracking\r\n            grid={grid}\r\n            getInitialGrid={getInitialGrid}\r\n            updateGridState={this.updateGridState}\r\n            startNode={this.state.startNode}\r\n            finishNode={this.state.finishNode}\r\n          />\r\n        </div>\r\n        <div className=\"table\">\r\n          {grid.map((row, rowIndex) => {\r\n            return (\r\n              <div className=\"table__row\" key={rowIndex}>\r\n                {row.map((node, nodeIndex) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    isWall,\r\n                    isVisited\r\n                  } = node;\r\n                  return (\r\n                    <SingleNode\r\n                      key={nodeIndex}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      isWall={isWall}\r\n                      isVisited={isVisited}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      setStartNode={(row, col) => this.setStartNode(row, col)}\r\n                      setFinishNode={(row, col) => this.setFinishNode(row, col)}\r\n                    ></SingleNode>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < TABLE_HEIGHT; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < TABLE_WIDTH; col++) {\r\n      currentRow.push(createNode(row, col));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (row, col) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === NODE_START[0] && col === NODE_START[1],\r\n    isFinish: row === NODE_FINISH[0] && col === NODE_FINISH[1],\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\nimport PathfindingVisualizer from \"./Pathfinding/PathfindingVisualizer\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Pathfinding visualization</h1>\n      </header>\n      <section className=\"App-container\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </section>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}