{"version":3,"sources":["Pathfinding/SingleNode.js","pathfindingAlgorithms/dijkstra.js","mazeGenerator/recursiveBacktracking.js","mazeGenerator/recursiveDivision.js","mazeGenerator/simpleVerticalWalls.js","Pathfinding/PathfindingVisualizer.js","App.js","index.js"],"names":["SingleNode","props","onDragOver","e","preventDefault","onDragStart","obj","isStart","isFinish","isWall","target","parentNode","classList","dataTransfer","setData","id","onDrop","stopPropagation","data","getData","setStartNode","row","col","appendChild","document","getElementById","setFinishNode","state","this","isVisited","onMouseEnter","onMouseDown","onMouseUp","extraClassName","className","aria-label","role","draggable","React","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","animateGrid","RecursiveBacktracking","dirs","gridH","gridMap","gridW","h","w","map","modDir","Math","round","clearBoard","getInitialGrid","updateGridState","isNaN","mh","mw","n","s","v","y","x","o","build","i","j","display","setSerachingState","task2","task","timer","ms","Promise","res","setTimeout","py","px","d","explore","toGrid","ex","ey","sortRand","nx","ny","a","out","l","p","floor","random","disabled","onClick","Maze","gapsArr","RecursiveDivision","addOuterWalls","addInnerWalls","minX","maxX","minY","maxY","randomNumber","addHWall","addVWall","gap","min","max","el","generate","SimpleVerticalWalls","animateWalls","num","verticalWalls","NODE_START","NODE_FINISH","TABLE_HEIGHT","TABLE_WIDTH","PathfindingVisualizer","newGrid","setState","value","isSearching","querySelectorAll","forEach","mouseIsPressed","getNewGridWithWallToggled","animateDijkstra","animateShortestPath","visualizeDijkstra","style","gridTemplateColumns","gridTemplateRows","nodeIndex","key","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.3e8ea368.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nclass SingleNode extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  onDragOver = e => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  onDragStart = (e, obj) => {\r\n    if ((obj.props.isStart || obj.props.isFinish) && !obj.props.isWall) {\r\n      e.target.parentNode.classList = \"node \";\r\n      e.dataTransfer.setData(\"text\", e.target.id);\r\n    }\r\n  };\r\n\r\n  onDrop = (e, obj) => {\r\n    e.stopPropagation();\r\n    e.preventDefault();\r\n\r\n    let data = e.dataTransfer.getData(\"text/plain\");\r\n\r\n    if (data === \"start-node\") {\r\n      e.target.classList = \"node node__start\";\r\n      this.props.setStartNode(obj.props.row, obj.props.col);\r\n      e.target.appendChild(document.getElementById(data));\r\n    } else if (data === \"finish-node\") {\r\n      e.target.classList = \"node node__finish\";\r\n      this.props.setFinishNode(obj.props.row, obj.props.col);\r\n      e.target.appendChild(document.getElementById(data));\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseEnter,\r\n      onMouseDown,\r\n      onMouseUp\r\n    } = this.props;\r\n    const extraClassName = isStart\r\n      ? \"node__start\"\r\n      : isFinish\r\n      ? \"node__finish\"\r\n      : isVisited\r\n      ? \"node__visited\"\r\n      : isWall\r\n      ? \"node__wall\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onDrop={e => this.onDrop(e, this)}\r\n        onDragOver={e => this.onDragOver(e)}\r\n      >\r\n        {isStart ? (\r\n          <span\r\n            aria-label=\"startNode\"\r\n            id=\"start-node\"\r\n            role=\"img\"\r\n            draggable=\"true\"\r\n            onDragStart={e => this.onDragStart(e, this)}\r\n          >\r\n            ▶️\r\n          </span>\r\n        ) : isFinish ? (\r\n          <span\r\n            aria-label=\"finishNode\"\r\n            id=\"finish-node\"\r\n            role=\"img\"\r\n            draggable=\"true\"\r\n            onDragStart={e => this.onDragStart(e, this)}\r\n          >\r\n            🏁\r\n          </span>\r\n        ) : (\r\n          \" \"\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SingleNode;\r\n","// Main dijkstra fn looping throughout all nodes in grid\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\n// Sort all unvisited nodes by distance\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n// Add distance + 1 to all unvisited nodes\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\n// Get all node neighbours (top,right,bottom,left)\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// Creating empty grid for dijktra\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Called after dijkstra algorithm, finding shortes path\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\n\r\nlet grid = [];\r\nlet animateGrid = [];\r\n\r\nclass RecursiveBacktracking extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n\r\n    this.dirs = [];\r\n    this.gridH = 0;\r\n    this.gridMap = [];\r\n    this.gridW = 0;\r\n    this.h = 0;\r\n    this.w = 0;\r\n    this.map = [];\r\n    this.modDir = {};\r\n  }\r\n\r\n  Maze(w, h, props) {\r\n    w = Math.round(w) - 1;\r\n    h = Math.round(h) - 1;\r\n\r\n    animateGrid = [];\r\n    props.clearBoard();\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.w = isNaN(w) || w < 5 || w > 999 ? 20 : w;\r\n    this.h = isNaN(h) || h < 5 || h > 999 ? 20 : h;\r\n    this.map = [];\r\n\r\n    // Initialize this.map with coordinates obj\r\n    for (var mh = 0; mh < h; ++mh) {\r\n      this.map[mh] = [];\r\n      for (var mw = 0; mw < w; ++mw) {\r\n        this.map[mh][mw] = { n: 0, s: 0, e: 0, w: 0, v: 0 };\r\n      }\r\n    }\r\n\r\n    this.dirs = [\"n\", \"s\", \"e\", \"w\"];\r\n    this.modDir = {\r\n      n: { y: -1, x: 0, o: \"s\" },\r\n      s: { y: 1, x: 0, o: \"n\" },\r\n      e: { y: 0, x: -1, o: \"w\" },\r\n      w: { y: 0, x: 1, o: \"e\" }\r\n    };\r\n\r\n    this.build(0, 0);\r\n\r\n    // Add walls to animate grid\r\n    for (let i = 0; i < this.gridMap.length - 1; i++) {\r\n      for (let j = 0; j < this.gridMap[i].length - 1; j++) {\r\n        if (\r\n          this.gridMap[i][j] === 0 ||\r\n          i === 0 ||\r\n          i === this.gridMap.length - 1 ||\r\n          j === 0 ||\r\n          j === this.gridMap[i].length - 1\r\n        ) {\r\n          if (\r\n            !this.props.grid[i][j].isStart &&\r\n            !this.props.grid[i][j].isFinish\r\n          ) {\r\n            animateGrid.push(this.props.grid[i][j]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.display(props);\r\n  }\r\n\r\n  // Animate walls\r\n  async display(props) {\r\n    props.setSerachingState(true);\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (\r\n          i === 0 ||\r\n          i === grid.length - 1 ||\r\n          j === 0 ||\r\n          j === grid[i].length - 1\r\n        ) {\r\n          await this.task2(i, j);\r\n          grid[i][j].isWall = true;\r\n        }\r\n      }\r\n    }\r\n    for (let i = 0; i < animateGrid.length; i++) {\r\n      await this.task(animateGrid, i);\r\n      grid[animateGrid[i].row][animateGrid[i].col].isWall = true;\r\n    }\r\n\r\n    props.setSerachingState(false);\r\n  }\r\n\r\n  async task(animateGrid, i) {\r\n    await this.timer(1);\r\n    const node = animateGrid[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node__wall\";\r\n  }\r\n\r\n  async task2(i, j) {\r\n    await this.timer(1);\r\n    document.getElementById(`node-${i}-${j}`).className = \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  // Convert coordinates grid to 0-1 grid, [1,1,1,1,0,0] where 0 is a wall and 1 is passage\r\n  toGrid() {\r\n    var grid = [];\r\n    for (var mh = 0; mh < this.h * 2 + 1; ++mh) {\r\n      grid[mh] = [];\r\n      for (var mw = 0; mw < this.w * 2 + 1; ++mw) {\r\n        grid[mh][mw] = 0;\r\n      }\r\n    }\r\n\r\n    for (var y = 0; y < this.h; ++y) {\r\n      var py = y * 2 + 1;\r\n\r\n      for (var x = 0; x < this.w; ++x) {\r\n        var px = x * 2 + 1;\r\n\r\n        if (this.map[y][x].v === 1) {\r\n          grid[py][px] = 1;\r\n        }\r\n\r\n        for (let d in this.dirs) {\r\n          if (this.map[y][x][this.dirs[d]] === 1) {\r\n            grid[py + this.modDir[this.dirs[d]].y][\r\n              px + this.modDir[this.dirs[d]].x\r\n            ] = 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.gridMap = grid;\r\n    this.gridW = grid.length;\r\n    this.gridH = grid[0].length;\r\n  }\r\n\r\n  build(x, y) {\r\n    x = 0;\r\n    y = 0;\r\n\r\n    this.explore(x, y);\r\n    this.toGrid();\r\n  }\r\n\r\n  // Explore all nodes on grid and decide which should be wall\r\n  explore(ex, ey) {\r\n    this.dirs = this.sortRand(this.dirs);\r\n\r\n    for (let d in this.dirs) {\r\n      var nx = ex + this.modDir[this.dirs[d]].x;\r\n      var ny = ey + this.modDir[this.dirs[d]].y;\r\n\r\n      if (\r\n        nx >= 0 &&\r\n        nx < this.w &&\r\n        ny >= 0 &&\r\n        ny < this.h &&\r\n        this.map[ny][nx].v === 0\r\n      ) {\r\n        this.map[ey][ex][this.dirs[d]] = 1;\r\n        this.map[ey][ex].v = 1;\r\n        this.map[ny][nx][this.modDir[this.dirs[d]].o] = 1;\r\n\r\n        this.explore(nx, ny);\r\n      }\r\n    }\r\n  }\r\n\r\n  sortRand(a) {\r\n    var out = [];\r\n    var l = a.length;\r\n\r\n    for (let x in a) {\r\n      do {\r\n        var p = Math.floor(Math.random() * (l * 1000)) % l;\r\n      } while (typeof out[p] != \"undefined\");\r\n\r\n      out[p] = a[x];\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button\r\n        disabled={props.disabled}\r\n        onClick={() =>\r\n          this.Maze(props.grid[0].length / 2, props.grid.length / 2, props)\r\n        }\r\n      >\r\n        Recursive Backtraciking\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RecursiveBacktracking;\r\n","import React from \"react\";\r\n\r\nlet grid;\r\nlet animateGrid = [];\r\nlet gapsArr = [];\r\n\r\nclass RecursiveDivision extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  generate(props) {\r\n    animateGrid = [];\r\n    props.clearBoard();\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.addOuterWalls();\r\n    this.addInnerWalls(true, 1, grid[0].length - 2, 1, grid.length - 2);\r\n    this.display(props);\r\n  }\r\n\r\n  // Add border walls\r\n  addOuterWalls() {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (i === 0 || i === grid.length - 1) {\r\n          animateGrid.push(grid[i][j]);\r\n        } else if (j === 0 || j === grid[i].length - 1) {\r\n          animateGrid.push(grid[i][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Add inner walls\r\n  addInnerWalls(h, minX, maxX, minY, maxY) {\r\n    if (h) {\r\n      if (maxX - minX < 2) {\r\n        return;\r\n      }\r\n\r\n      const y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2;\r\n      this.addHWall(minX, maxX, y);\r\n\r\n      // If !h will return in 'maxY - minY < 2' then use second call\r\n      this.addInnerWalls(!h, minX, maxX, minY, y - 1);\r\n      this.addInnerWalls(!h, minX, maxX, y + 1, maxY);\r\n    } else {\r\n      if (maxY - minY < 2) {\r\n        return;\r\n      }\r\n\r\n      const x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2;\r\n      this.addVWall(minY, maxY, x);\r\n\r\n      this.addInnerWalls(!h, minX, x - 1, minY, maxY);\r\n      this.addInnerWalls(!h, x + 1, maxX, minY, maxY);\r\n    }\r\n  }\r\n\r\n  // Adding horizontal walls\r\n  addHWall(minX, maxX, y) {\r\n    const gap = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1;\r\n    gapsArr.push(grid[y][gap]);\r\n\r\n    for (let i = minX; i <= maxX; i++) {\r\n      if (i !== gap) {\r\n        animateGrid.push(grid[y][i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Adding vertical walls\r\n  addVWall(minY, maxY, x) {\r\n    const gap = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\r\n    gapsArr.push(grid[gap][x]);\r\n\r\n    for (let i = minY; i <= maxY; i++) {\r\n      if (i !== gap) {\r\n        animateGrid.push(grid[i][x]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Helper function generating random between min - max\r\n  randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n  }\r\n\r\n  // Animate walls\r\n  async display(props) {\r\n    props.setSerachingState(true);\r\n\r\n    // const differenceArray = animateGrid.filter(x => !gapsArr.includes(x));\r\n\r\n    for (let i = 0; i < animateGrid.length; i++) {\r\n      await this.task(animateGrid, i);\r\n      animateGrid[i].isWall = true;\r\n    }\r\n\r\n    gapsArr.map(el => {\r\n      return (el.isWall = false);\r\n      // document.getElementById(`node-${el.row}-${el.col}`).className = \"node \";\r\n    });\r\n\r\n    props.setSerachingState(false);\r\n  }\r\n\r\n  // Async fn delaying animation\r\n  async task(animateGrid, i) {\r\n    await this.timer(5);\r\n    const node = animateGrid[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button disabled={props.disabled} onClick={() => this.generate(props)}>\r\n        Revursive Division\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RecursiveDivision;\r\n","import React from \"react\";\r\n\r\nlet grid;\r\n\r\nclass SimpleVerticalWalls extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  verticalWalls(props) {\r\n    props.clearBoard();\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.animateWalls(props);\r\n  }\r\n\r\n  async animateWalls(props) {\r\n    props.setSerachingState(true);\r\n\r\n    // Generate border walls\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (\r\n          i === 0 ||\r\n          i === grid.length - 1 ||\r\n          j === 0 ||\r\n          j === grid[i].length - 1\r\n        ) {\r\n          await this.task2(i, j);\r\n          grid[i][j].isWall = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Generate vertical walls with a gap\r\n    for (let i = 0; i < grid[0].length - 2; i += 2) {\r\n      const num = Math.floor(Math.random() * (grid.length - 2)) + 1;\r\n      const gap = grid[num][i];\r\n\r\n      for (let j = 1; j < grid.length - 1; j++) {\r\n        if (grid[j][i] !== gap) {\r\n          await this.task2(j, i);\r\n          grid[j][i].isWall = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    props.setSerachingState(false);\r\n  }\r\n\r\n  async task2(i, j) {\r\n    await this.timer(5);\r\n    document.getElementById(`node-${i}-${j}`).className = \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button\r\n        disabled={props.disabled}\r\n        onClick={() => this.verticalWalls(props)}\r\n      >\r\n        Horizontal Walls\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SimpleVerticalWalls;\r\n","import React from \"react\";\r\nimport SingleNode from \"./SingleNode\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../pathfindingAlgorithms/dijkstra\";\r\nimport RecursiveBacktracking from \"../mazeGenerator/recursiveBacktracking\";\r\nimport RecursiveDivision from \"../mazeGenerator/recursiveDivision\";\r\nimport SimpleVerticalWalls from \"../mazeGenerator/simpleVerticalWalls\";\r\n\r\nconst TABLE_WIDTH = 71;\r\nconst TABLE_HEIGHT = 31;\r\nconst NODE_START = [1, 1];\r\nconst NODE_FINISH = [TABLE_HEIGHT - 2, TABLE_WIDTH - 2];\r\n\r\nexport default class PathfindingVisualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      startNode: [NODE_START[0], NODE_START[1]],\r\n      finishNode: [NODE_FINISH[0], NODE_FINISH[1]],\r\n      isSearching: false\r\n    };\r\n  }\r\n\r\n  // #region Helper Functions\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isSearching) {\r\n      if (\r\n        !this.state.grid[row][col].isStart &&\r\n        !this.state.grid[row][col].isFinish\r\n      ) {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        // this.toggleWalls(this.state.grid, row, col);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isSearching) {\r\n      if (!this.state.mouseIsPressed) return;\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      // this.toggleWalls(this.state.grid, row, col);\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  setStartNode(row, col) {\r\n    this.setState({ startNode: [row, col] });\r\n  }\r\n\r\n  setFinishNode(row, col) {\r\n    this.setState({ finishNode: [row, col] });\r\n  }\r\n\r\n  toggleWalls(grid, row, col) {\r\n    if (!grid[row][col].isWall) {\r\n      grid[row][col].isWall = true;\r\n    } else {\r\n      grid[row][col].isWall = false;\r\n    }\r\n  }\r\n\r\n  updateGridState = newGrid => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  setSerachingState = value => {\r\n    this.setState({ isSearching: value });\r\n  };\r\n\r\n  clearBoard = () => {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      el.className = \"node \";\r\n      if (\r\n        el.id === `node-${this.state.startNode[0]}-${this.state.startNode[1]}`\r\n      ) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.finishNode[0]}-${this.state.finishNode[1]}`\r\n      ) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n  };\r\n\r\n  // #endregion\r\n\r\n  // #region Dijkstra pathfinding algorithm\r\n\r\n  async visualizeDijkstra() {\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      if (el.className !== \"node node__wall\") {\r\n        el.className = \"node \";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.startNode[0]}-${this.state.startNode[1]}`\r\n      ) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.finishNode[0]}-${this.state.finishNode[1]}`\r\n      ) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n\r\n    await this.setState({ isSearching: true });\r\n\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startNode[0]][this.state.startNode[1]];\r\n    const finishNode = grid[this.state.finishNode[0]][this.state.finishNode[1]];\r\n    const visitedNodesInOrder = await dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = await getNodesInShortestPathOrder(\r\n      finishNode\r\n    );\r\n    await this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node__visited\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node__shortest-path\";\r\n      }, 20 * i);\r\n    }\r\n\r\n    this.setState({ isSearching: false });\r\n  }\r\n\r\n  // #endregion\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed, isSearching } = this.state;\r\n    return (\r\n      <>\r\n        <header className=\"App-header\">\r\n          <h1 className=\"App-header__title\">Pathfinding visualization</h1>\r\n          <div className=\"config-desc\">\r\n            <h3 className=\"config-desc__config\">Config</h3>\r\n            <h3 className=\"config-desc__pathfinding\">Pathfinding</h3>\r\n            <h3 className=\"config-desc__mazes\">Generate Maze</h3>\r\n          </div>\r\n          <div className=\"config-buttons\">\r\n            <button disabled={isSearching} onClick={() => this.clearBoard()}>\r\n              Clear board\r\n            </button>\r\n            <button\r\n              disabled={isSearching}\r\n              onClick={() => this.visualizeDijkstra()}\r\n            >\r\n              Start Dijkstra's Algorithm\r\n            </button>\r\n            <div className=\"maze-generators\">\r\n              <SimpleVerticalWalls\r\n                setSerachingState={this.setSerachingState}\r\n                disabled={isSearching}\r\n                grid={grid}\r\n                getInitialGrid={getInitialGrid}\r\n                updateGridState={this.updateGridState}\r\n                startNode={this.state.startNode}\r\n                finishNode={this.state.finishNode}\r\n                clearBoard={this.clearBoard}\r\n              />\r\n              <RecursiveDivision\r\n                setSerachingState={this.setSerachingState}\r\n                disabled={isSearching}\r\n                grid={grid}\r\n                getInitialGrid={getInitialGrid}\r\n                updateGridState={this.updateGridState}\r\n                startNode={this.state.startNode}\r\n                finishNode={this.state.finishNode}\r\n                clearBoard={this.clearBoard}\r\n              />\r\n              <RecursiveBacktracking\r\n                setSerachingState={this.setSerachingState}\r\n                disabled={isSearching}\r\n                grid={grid}\r\n                getInitialGrid={getInitialGrid}\r\n                updateGridState={this.updateGridState}\r\n                startNode={this.state.startNode}\r\n                finishNode={this.state.finishNode}\r\n                clearBoard={this.clearBoard}\r\n              />\r\n            </div>\r\n          </div>\r\n        </header>\r\n        <section className=\"table-container\">\r\n          <div\r\n            className=\"table\"\r\n            style={{\r\n              gridTemplateColumns: `repeat(${TABLE_WIDTH}, 20px)`,\r\n              gridTemplateRows: `repeat(${TABLE_HEIGHT}, 20px)`\r\n            }}\r\n          >\r\n            {grid.map(row => {\r\n              return row.map((node, nodeIndex) => {\r\n                const {\r\n                  row,\r\n                  col,\r\n                  isStart,\r\n                  isFinish,\r\n                  isWall = false,\r\n                  isVisited\r\n                } = node;\r\n                return (\r\n                  <SingleNode\r\n                    key={nodeIndex}\r\n                    row={row}\r\n                    col={col}\r\n                    isStart={isStart}\r\n                    isFinish={isFinish}\r\n                    isWall={isWall}\r\n                    isVisited={isVisited}\r\n                    mouseIsPressed={mouseIsPressed}\r\n                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                    onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                    onMouseUp={() => this.handleMouseUp()}\r\n                    setStartNode={(row, col) => this.setStartNode(row, col)}\r\n                    setFinishNode={(row, col) => this.setFinishNode(row, col)}\r\n                  ></SingleNode>\r\n                );\r\n              });\r\n            })}\r\n          </div>\r\n        </section>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n// Initialize empty grid\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < TABLE_HEIGHT; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < TABLE_WIDTH; col++) {\r\n      currentRow.push(createNode(row, col));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\n// Initial node obj\r\nconst createNode = (row, col) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === NODE_START[0] && col === NODE_START[1],\r\n    isFinish: row === NODE_FINISH[0] && col === NODE_FINISH[1],\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null\r\n  };\r\n};\r\n\r\n// Draw walls on grid\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\nimport PathfindingVisualizer from \"./Pathfinding/PathfindingVisualizer\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <section className=\"App-container\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </section>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}