{"version":3,"sources":["Pathfinding/SingleNode.js","pathfindingAlgorithms/dijkstra.js","mazeGenerator/recursiveBacktracking.js","mazeGenerator/recursiveDivision.js","mazeGenerator/simpleVerticalWalls.js","Pathfinding/PathfindingVisualizer.js","App.js","index.js"],"names":["SingleNode","props","onDragOver","e","preventDefault","onDragStart","obj","isStart","isFinish","isWall","target","parentNode","classList","dataTransfer","setData","id","onDrop","stopPropagation","data","getData","setStartNode","row","col","appendChild","document","getElementById","setFinishNode","state","this","isVisited","onMouseEnter","onMouseDown","onMouseUp","extraClassName","className","aria-label","role","draggable","React","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","animateGrid","RecursiveBacktracking","dirs","gridH","gridMap","gridW","h","w","map","modDir","Math","round","console","log","clearBoard","getInitialGrid","updateGridState","isNaN","mh","mw","n","s","v","y","x","o","build","i","j","display","task2","task","timer","ms","Promise","res","setTimeout","py","px","d","explore","toGrid","ex","ey","sortRand","nx","ny","a","out","l","p","floor","random","onClick","Maze","gapsArr","RecursiveDivision","addOuterWalls","addInnerWalls","minX","maxX","minY","maxY","randomNumber","addHWall","addVWall","hole","min","max","el","generate","SimpleVerticalWalls","animateWalls","num","gap","verticalWalls","NODE_START","NODE_FINISH","TABLE_HEIGHT","TABLE_WIDTH","PathfindingVisualizer","newGrid","setState","querySelectorAll","forEach","mouseIsPressed","isSearching","getNewGridWithWallToggled","animateDijkstra","animateShortestPath","visualizeDijkstra","style","gridTemplateColumns","gridTemplateRows","nodeIndex","key","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","slice","newNode","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.2f5278c3.chunk.js","sourcesContent":["import React from \"react\";\r\n\r\nclass SingleNode extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  onDragOver = e => {\r\n    e.preventDefault();\r\n  };\r\n\r\n  onDragStart = (e, obj) => {\r\n    if ((obj.props.isStart || obj.props.isFinish) && !obj.props.isWall) {\r\n      e.target.parentNode.classList = \"node \";\r\n      e.dataTransfer.setData(\"text\", e.target.id);\r\n    }\r\n  };\r\n\r\n  onDrop = (e, obj) => {\r\n    e.stopPropagation();\r\n    e.preventDefault();\r\n\r\n    let data = e.dataTransfer.getData(\"text/plain\");\r\n\r\n    if (data === \"start-node\") {\r\n      e.target.classList = \"node node__start\";\r\n      this.props.setStartNode(obj.props.row, obj.props.col);\r\n      e.target.appendChild(document.getElementById(data));\r\n    } else if (data === \"finish-node\") {\r\n      e.target.classList = \"node node__finish\";\r\n      this.props.setFinishNode(obj.props.row, obj.props.col);\r\n      e.target.appendChild(document.getElementById(data));\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseEnter,\r\n      onMouseDown,\r\n      onMouseUp\r\n    } = this.props;\r\n    const extraClassName = isStart\r\n      ? \"node__start\"\r\n      : isFinish\r\n      ? \"node__finish\"\r\n      : isVisited\r\n      ? \"node__visited\"\r\n      : isWall\r\n      ? \"node__wall\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onDrop={e => this.onDrop(e, this)}\r\n        onDragOver={e => this.onDragOver(e)}\r\n      >\r\n        {isStart ? (\r\n          <span\r\n            aria-label=\"startNode\"\r\n            id=\"start-node\"\r\n            role=\"img\"\r\n            draggable=\"true\"\r\n            onDragStart={e => this.onDragStart(e, this)}\r\n          >\r\n            ‚ñ∂Ô∏è\r\n          </span>\r\n        ) : isFinish ? (\r\n          <span\r\n            aria-label=\"finishNode\"\r\n            id=\"finish-node\"\r\n            role=\"img\"\r\n            draggable=\"true\"\r\n            onDragStart={e => this.onDragStart(e, this)}\r\n          >\r\n            üèÅ\r\n          </span>\r\n        ) : (\r\n          \" \"\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SingleNode;\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// Creating empty grid for dijktra\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Called after dijkstra algorithm, finding shortes path\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\n\r\nlet grid = [];\r\nlet animateGrid = [];\r\n\r\nclass RecursiveBacktracking extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.dirs = [];\r\n    this.gridH = 0;\r\n    this.gridMap = [];\r\n    this.gridW = 0;\r\n    this.h = 0;\r\n    this.w = 0;\r\n    this.map = [];\r\n    this.modDir = {};\r\n  }\r\n\r\n  Maze(w, h, props) {\r\n    w = Math.round(w) - 1;\r\n    h = Math.round(h) - 1;\r\n\r\n    console.log(w, h);\r\n\r\n    animateGrid = [];\r\n    props.clearBoard();\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.w = isNaN(w) || w < 5 || w > 999 ? 20 : w;\r\n    this.h = isNaN(h) || h < 5 || h > 999 ? 20 : h;\r\n    this.map = [];\r\n\r\n    for (var mh = 0; mh < h; ++mh) {\r\n      this.map[mh] = [];\r\n      for (var mw = 0; mw < w; ++mw) {\r\n        this.map[mh][mw] = { n: 0, s: 0, e: 0, w: 0, v: 0 };\r\n      }\r\n    }\r\n\r\n    this.dirs = [\"n\", \"s\", \"e\", \"w\"];\r\n    this.modDir = {\r\n      n: { y: -1, x: 0, o: \"s\" },\r\n      s: { y: 1, x: 0, o: \"n\" },\r\n      e: { y: 0, x: -1, o: \"w\" },\r\n      w: { y: 0, x: 1, o: \"e\" }\r\n    };\r\n\r\n    this.build(0, 0);\r\n\r\n    for (let i = 0; i < this.gridMap.length - 1; i++) {\r\n      for (let j = 0; j < this.gridMap[i].length - 1; j++) {\r\n        if (\r\n          this.gridMap[i][j] === 0 ||\r\n          i === 0 ||\r\n          i === this.gridMap.length - 1 ||\r\n          j === 0 ||\r\n          j === this.gridMap[i].length - 1\r\n        ) {\r\n          if (\r\n            !this.props.grid[i][j].isStart &&\r\n            !this.props.grid[i][j].isFinish\r\n          ) {\r\n            animateGrid.push(this.props.grid[i][j]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.display();\r\n  }\r\n\r\n  async display() {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (\r\n          i === 0 ||\r\n          i === grid.length - 1 ||\r\n          j === 0 ||\r\n          j === grid[i].length - 1\r\n        ) {\r\n          await this.task2(i, j);\r\n          grid[i][j].isWall = true;\r\n        }\r\n      }\r\n    }\r\n    for (let i = 0; i < animateGrid.length; i++) {\r\n      await this.task(animateGrid, i);\r\n      grid[animateGrid[i].row][animateGrid[i].col].isWall = true;\r\n    }\r\n  }\r\n\r\n  async task(animateGrid, i) {\r\n    await this.timer(1);\r\n    const node = animateGrid[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node__wall\";\r\n  }\r\n\r\n  async task2(i, j) {\r\n    await this.timer(1);\r\n    document.getElementById(`node-${i}-${j}`).className = \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  toGrid() {\r\n    var grid = [];\r\n    for (var mh = 0; mh < this.h * 2 + 1; ++mh) {\r\n      grid[mh] = [];\r\n      for (var mw = 0; mw < this.w * 2 + 1; ++mw) {\r\n        grid[mh][mw] = 0;\r\n      }\r\n    }\r\n\r\n    for (var y = 0; y < this.h; ++y) {\r\n      var py = y * 2 + 1;\r\n\r\n      for (var x = 0; x < this.w; ++x) {\r\n        var px = x * 2 + 1;\r\n\r\n        if (this.map[y][x].v === 1) {\r\n          grid[py][px] = 1;\r\n        }\r\n\r\n        for (let d in this.dirs) {\r\n          if (this.map[y][x][this.dirs[d]] === 1) {\r\n            grid[py + this.modDir[this.dirs[d]].y][\r\n              px + this.modDir[this.dirs[d]].x\r\n            ] = 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.gridMap = grid;\r\n    this.gridW = grid.length;\r\n    this.gridH = grid[0].length;\r\n  }\r\n\r\n  build(x, y) {\r\n    x = 0;\r\n    y = 0;\r\n\r\n    this.explore(x, y);\r\n    this.toGrid();\r\n  }\r\n\r\n  explore(ex, ey) {\r\n    this.dirs = this.sortRand(this.dirs);\r\n\r\n    for (let d in this.dirs) {\r\n      var nx = ex + this.modDir[this.dirs[d]].x;\r\n      var ny = ey + this.modDir[this.dirs[d]].y;\r\n\r\n      if (\r\n        nx >= 0 &&\r\n        nx < this.w &&\r\n        ny >= 0 &&\r\n        ny < this.h &&\r\n        this.map[ny][nx].v === 0\r\n      ) {\r\n        this.map[ey][ex][this.dirs[d]] = 1;\r\n        this.map[ey][ex].v = 1;\r\n        this.map[ny][nx][this.modDir[this.dirs[d]].o] = 1;\r\n\r\n        this.explore(nx, ny);\r\n      }\r\n    }\r\n  }\r\n\r\n  sortRand(a) {\r\n    var out = [];\r\n    var l = a.length;\r\n\r\n    for (let x in a) {\r\n      do {\r\n        var p = Math.floor(Math.random() * (l * 1000)) % l;\r\n      } while (typeof out[p] != \"undefined\");\r\n\r\n      out[p] = a[x];\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button\r\n        onClick={() =>\r\n          this.Maze(props.grid[0].length / 2, props.grid.length / 2, props)\r\n        }\r\n      >\r\n        Recursive Backtraciking\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RecursiveBacktracking;\r\n","import React from \"react\";\r\n\r\nlet grid;\r\nlet animateGrid = [];\r\nlet gapsArr = [];\r\n\r\nclass RecursiveDivision extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n\r\n  generate(props) {\r\n    animateGrid = [];\r\n    props.clearBoard();\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.addOuterWalls();\r\n    this.addInnerWalls(true, 1, grid[0].length - 2, 1, grid.length - 2);\r\n    this.display();\r\n  }\r\n\r\n  addOuterWalls() {\r\n    for (var i = 0; i < grid.length; i++) {\r\n      for (var j = 0; j < grid[i].length; j++) {\r\n        if (i === 0 || i === grid.length - 1) {\r\n          animateGrid.push(grid[i][j]);\r\n        } else if (j === 0 || j === grid[i].length - 1) {\r\n          animateGrid.push(grid[i][j]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  addInnerWalls(h, minX, maxX, minY, maxY) {\r\n    if (h) {\r\n      if (maxX - minX < 2) {\r\n        return;\r\n      }\r\n\r\n      var y = Math.floor(this.randomNumber(minY, maxY) / 2) * 2;\r\n      this.addHWall(minX, maxX, y);\r\n\r\n      this.addInnerWalls(!h, minX, maxX, minY, y - 1);\r\n      this.addInnerWalls(!h, minX, maxX, y + 1, maxY);\r\n    } else {\r\n      if (maxY - minY < 2) {\r\n        return;\r\n      }\r\n\r\n      var x = Math.floor(this.randomNumber(minX, maxX) / 2) * 2;\r\n      this.addVWall(minY, maxY, x);\r\n\r\n      this.addInnerWalls(!h, minX, x - 1, minY, maxY);\r\n      this.addInnerWalls(!h, x + 1, maxX, minY, maxY);\r\n    }\r\n  }\r\n\r\n  addHWall(minX, maxX, y) {\r\n    var hole = Math.floor(this.randomNumber(minX, maxX) / 2) * 2 + 1;\r\n    gapsArr.push(grid[y][hole]);\r\n\r\n    for (var i = minX; i <= maxX; i++) {\r\n      if (i !== hole) {\r\n        animateGrid.push(grid[y][i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  addVWall(minY, maxY, x) {\r\n    var hole = Math.floor(this.randomNumber(minY, maxY) / 2) * 2 + 1;\r\n    gapsArr.push(grid[hole][x]);\r\n\r\n    for (var i = minY; i <= maxY; i++) {\r\n      if (i !== hole) {\r\n        animateGrid.push(grid[i][x]);\r\n      }\r\n    }\r\n  }\r\n\r\n  randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n  }\r\n\r\n  async display() {\r\n    for (let i = 0; i < animateGrid.length; i++) {\r\n      await this.task(animateGrid, i);\r\n      animateGrid[i].isWall = true;\r\n    }\r\n\r\n    gapsArr.map(el => (el.isWall = false));\r\n  }\r\n\r\n  async task(animateGrid, i) {\r\n    await this.timer(1);\r\n    const node = animateGrid[i];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button onClick={() => this.generate(props)}>Revursive Division</button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default RecursiveDivision;\r\n","import React from \"react\";\r\n\r\nlet grid;\r\n\r\nclass SimpleVerticalWalls extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  verticalWalls(props) {\r\n    props.clearBoard();\r\n    grid = props.grid;\r\n    grid = props.getInitialGrid();\r\n    props.updateGridState(grid);\r\n\r\n    this.animateWalls();\r\n  }\r\n\r\n  async animateWalls() {\r\n    for (let i = 0; i < grid.length; i++) {\r\n      for (let j = 0; j < grid[i].length; j++) {\r\n        if (\r\n          i === 0 ||\r\n          i === grid.length - 1 ||\r\n          j === 0 ||\r\n          j === grid[i].length - 1\r\n        ) {\r\n          await this.task2(i, j);\r\n          grid[i][j].isWall = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < grid[0].length - 2; i += 2) {\r\n      const num = Math.floor(Math.random() * (grid.length - 2)) + 1;\r\n      const gap = grid[num][i];\r\n\r\n      for (let j = 1; j < grid.length - 1; j++) {\r\n        if (grid[j][i] !== gap) {\r\n          await this.task2(j, i);\r\n          grid[j][i].isWall = true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  async task2(i, j) {\r\n    await this.timer(5);\r\n    document.getElementById(`node-${i}-${j}`).className = \"node node__wall\";\r\n  }\r\n\r\n  timer(ms) {\r\n    return new Promise(res => setTimeout(res, ms));\r\n  }\r\n\r\n  render() {\r\n    const props = this.props;\r\n    return (\r\n      <button onClick={() => this.verticalWalls(props)}>\r\n        Horizontal Walls\r\n      </button>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SimpleVerticalWalls;\r\n","import React from \"react\";\r\nimport SingleNode from \"./SingleNode\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder\r\n} from \"../pathfindingAlgorithms/dijkstra\";\r\nimport RecursiveBacktracking from \"../mazeGenerator/recursiveBacktracking\";\r\nimport RecursiveDivision from \"../mazeGenerator/recursiveDivision\";\r\nimport SimpleVerticalWalls from \"../mazeGenerator/simpleVerticalWalls\";\r\n\r\nconst TABLE_WIDTH = 71;\r\nconst TABLE_HEIGHT = 31;\r\nconst NODE_START = [1, 1];\r\nconst NODE_FINISH = [TABLE_HEIGHT - 2, TABLE_WIDTH - 2];\r\n\r\nexport default class PathfindingVisualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      startNode: [NODE_START[0], NODE_START[1]],\r\n      finishNode: [NODE_FINISH[0], NODE_FINISH[1]],\r\n      isSearching: false\r\n    };\r\n  }\r\n\r\n  // #region Helper Functions\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (!this.state.isSearching) {\r\n      if (\r\n        !this.state.grid[row][col].isStart &&\r\n        !this.state.grid[row][col].isFinish\r\n      ) {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        // this.toggleWalls(this.state.grid, row, col);\r\n      }\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.isSearching) {\r\n      if (!this.state.mouseIsPressed) return;\r\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n      // this.toggleWalls(this.state.grid, row, col);\r\n    }\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  setStartNode(row, col) {\r\n    this.setState({ startNode: [row, col] });\r\n  }\r\n\r\n  setFinishNode(row, col) {\r\n    this.setState({ finishNode: [row, col] });\r\n  }\r\n\r\n  toggleWalls(grid, row, col) {\r\n    if (!grid[row][col].isWall) {\r\n      grid[row][col].isWall = true;\r\n    } else {\r\n      grid[row][col].isWall = false;\r\n    }\r\n  }\r\n\r\n  updateGridState = newGrid => {\r\n    this.setState({ grid: newGrid });\r\n  };\r\n\r\n  clearBoard = () => {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      el.className = \"node \";\r\n      if (\r\n        el.id === `node-${this.state.startNode[0]}-${this.state.startNode[1]}`\r\n      ) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.finishNode[0]}-${this.state.finishNode[1]}`\r\n      ) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n  };\r\n\r\n  // #endregion\r\n\r\n  // #region Dijkstra pathfinding algorithm\r\n\r\n  async visualizeDijkstra() {\r\n    document.querySelectorAll(\".node\").forEach(el => {\r\n      if (el.className !== \"node node__wall\") {\r\n        el.className = \"node \";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.startNode[0]}-${this.state.startNode[1]}`\r\n      ) {\r\n        el.className = \"node node__start\";\r\n      }\r\n      if (\r\n        el.id === `node-${this.state.finishNode[0]}-${this.state.finishNode[1]}`\r\n      ) {\r\n        el.className = \"node node__finish\";\r\n      }\r\n    });\r\n\r\n    await this.setState({ isSearching: true });\r\n\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.startNode[0]][this.state.startNode[1]];\r\n    const finishNode = grid[this.state.finishNode[0]][this.state.finishNode[1]];\r\n    const visitedNodesInOrder = await dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = await getNodesInShortestPathOrder(\r\n      finishNode\r\n    );\r\n    await this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node__visited\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node__shortest-path\";\r\n      }, 20 * i);\r\n    }\r\n\r\n    this.setState({ isSearching: false });\r\n  }\r\n\r\n  // #endregion\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n    return (\r\n      <>\r\n        <div className=\"config-desc\">\r\n          <h3 className=\"config-desc__config\">Config</h3>\r\n          <h3 className=\"config-desc__pathfinding\">Pathfinding</h3>\r\n          <h3 className=\"config-desc__mazes\">Generate Maze</h3>\r\n        </div>\r\n        <div className=\"config-buttons\">\r\n          <button onClick={() => this.clearBoard()}>Clear board</button>\r\n          <button onClick={() => this.visualizeDijkstra()}>\r\n            Start Dijkstra's Algorithm\r\n          </button>\r\n          <div className=\"maze-generators\">\r\n            <SimpleVerticalWalls\r\n              grid={grid}\r\n              getInitialGrid={getInitialGrid}\r\n              updateGridState={this.updateGridState}\r\n              startNode={this.state.startNode}\r\n              finishNode={this.state.finishNode}\r\n              clearBoard={this.clearBoard}\r\n            />\r\n            <RecursiveDivision\r\n              grid={grid}\r\n              getInitialGrid={getInitialGrid}\r\n              updateGridState={this.updateGridState}\r\n              startNode={this.state.startNode}\r\n              finishNode={this.state.finishNode}\r\n              clearBoard={this.clearBoard}\r\n            />\r\n            <RecursiveBacktracking\r\n              grid={grid}\r\n              getInitialGrid={getInitialGrid}\r\n              updateGridState={this.updateGridState}\r\n              startNode={this.state.startNode}\r\n              finishNode={this.state.finishNode}\r\n              clearBoard={this.clearBoard}\r\n            />\r\n          </div>\r\n        </div>\r\n        <div\r\n          className=\"table\"\r\n          style={{\r\n            gridTemplateColumns: `repeat(${TABLE_WIDTH}, 20px)`,\r\n            gridTemplateRows: `repeat(${TABLE_HEIGHT}, 20px)`\r\n          }}\r\n        >\r\n          {grid.map(row => {\r\n            return row.map((node, nodeIndex) => {\r\n              const {\r\n                row,\r\n                col,\r\n                isStart,\r\n                isFinish,\r\n                isWall = false,\r\n                isVisited\r\n              } = node;\r\n              return (\r\n                <SingleNode\r\n                  key={nodeIndex}\r\n                  row={row}\r\n                  col={col}\r\n                  isStart={isStart}\r\n                  isFinish={isFinish}\r\n                  isWall={isWall}\r\n                  isVisited={isVisited}\r\n                  mouseIsPressed={mouseIsPressed}\r\n                  onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                  onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                  onMouseUp={() => this.handleMouseUp()}\r\n                  setStartNode={(row, col) => this.setStartNode(row, col)}\r\n                  setFinishNode={(row, col) => this.setFinishNode(row, col)}\r\n                ></SingleNode>\r\n              );\r\n            });\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < TABLE_HEIGHT; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < TABLE_WIDTH; col++) {\r\n      currentRow.push(createNode(row, col));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (row, col) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === NODE_START[0] && col === NODE_START[1],\r\n    isFinish: row === NODE_FINISH[0] && col === NODE_FINISH[1],\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\nimport PathfindingVisualizer from \"./Pathfinding/PathfindingVisualizer\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Pathfinding visualization</h1>\n      </header>\n      <section className=\"App-container\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </section>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}